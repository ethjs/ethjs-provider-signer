{"version":3,"file":"ethjs-provider-signer.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap deb63ede8aa90218bcaa","webpack:///./lib/index.js","webpack:///./~/ethjs-provider-http/lib/index.js","webpack:///./~/ethjs-rpc/lib/index.js","webpack:///./~/xhr2/lib/browser.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SignerProvider\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SignerProvider\"] = factory();\n\telse\n\t\troot[\"SignerProvider\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap deb63ede8aa90218bcaa","'use strict';\n\nvar HTTPProvider = require('ethjs-provider-http');\nvar EthRPC = require('ethjs-rpc');\n\nmodule.exports = SignerProvider;\n\n/**\n * Signer provider constructor\n *\n * @method SignerProvider\n * @param {String} path the input data payload\n * @param {Object} options the send async callback\n * @returns {Object} provider instance\n */\nfunction SignerProvider(path, options) {\n  if (!(this instanceof SignerProvider)) {\n    throw new Error('[ethjs-provider-signer] the SignerProvider instance requires the \"new\" flag in order to function normally (e.g. `const eth = new Eth(new SignerProvider(...));`).');\n  }\n  if (typeof options !== 'object') {\n    throw new Error('[ethjs-provider-signer] the SignerProvider requires an options object be provided with the \\'privateKey\\' property specified, you provided type ' + typeof options + '.');\n  }\n  if (typeof options.signTransaction !== 'function') {\n    throw new Error('[ethjs-provider-signer] the SignerProvider requires an options object be provided with the \\'signTransaction\\' property specified, you provided type ' + typeof options.privateKey + ' (e.g. \\'const eth = new Eth(new SignerProvider(\"http://ropsten.infura.io\", { privateKey: (account, cb) => cb(null, \\'some private key\\') }));\\').');\n  }\n\n  var self = this;\n  self.options = Object.assign({\n    provider: HTTPProvider\n  }, options);\n  self.timeout = options.timeout || 0;\n  self.provider = new self.options.provider(path, self.timeout); // eslint-disable-line\n  self.rpc = new EthRPC(self.provider);\n}\n\n/**\n * Send async override\n *\n * @method sendAsync\n * @param {payload} payload the input data payload\n * @param {Function} callback the send async callback\n * @callback {Object} output the XMLHttpRequest payload\n */\nSignerProvider.prototype.sendAsync = function (payload, callback) {\n  // eslint-disable-line\n  var self = this;\n  if (payload.method === 'eth_accounts' && self.options.accounts) {\n    self.options.accounts(function (accountsError, accounts) {\n      // create new output payload\n      var inputPayload = Object.assign({}, {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        result: accounts\n      });\n\n      callback(accountsError, inputPayload);\n    });\n  } else if (payload.method === 'eth_sendTransaction') {\n    // get the nonce, if any\n    self.rpc.sendAsync({ method: 'eth_getTransactionCount', params: [payload.params[0].from, 'latest'] }, function (nonceError, nonce) {\n      // eslint-disable-line\n      if (nonceError) {\n        return callback(new Error('[ethjs-provider-signer] while getting nonce: ' + nonceError), null);\n      }\n\n      // get the gas price, if any\n      self.rpc.sendAsync({ method: 'eth_gasPrice' }, function (gasPriceError, gasPrice) {\n        // eslint-disable-line\n        if (gasPriceError) {\n          return callback(new Error('[ethjs-provider-signer] while getting gasPrice: ' + gasPriceError), null);\n        }\n\n        // build raw tx payload with nonce and gasprice as defaults to be overriden\n        var rawTxPayload = Object.assign({\n          nonce: nonce,\n          gasPrice: gasPrice\n        }, payload.params[0]);\n\n        // sign transaction with raw tx payload\n        self.options.signTransaction(rawTxPayload, function (keyError, signedHexPayload) {\n          // eslint-disable-line\n          if (!keyError) {\n            // create new output payload\n            var outputPayload = Object.assign({}, {\n              id: payload.id,\n              jsonrpc: payload.jsonrpc,\n              method: 'eth_sendRawTransaction',\n              params: [signedHexPayload]\n            });\n\n            // send payload\n            self.provider.sendAsync(outputPayload, callback);\n          } else {\n            // Return all the errors as is because they are application specific\n            console.error('[ethjs-provider-signer] while signing your transaction payload:', keyError);\n            callback(keyError, null);\n          }\n        });\n      });\n    });\n  } else {\n    self.provider.sendAsync(payload, callback);\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/index.js\n// module id = 0\n// module chunks = 0","'use strict';\n\n/**\n * @original-authors:\n *   Marek Kotewicz <marek@ethdev.com>\n *   Marian Oancea <marian@ethdev.com>\n *   Fabian Vogelsteller <fabian@ethdev.com>\n * @date 2015\n */\n\n// workaround to use httpprovider in different envs\nvar XHR2 = require('xhr2');\n\n/**\n * InvalidResponseError helper for invalid errors.\n */\nfunction invalidResponseError(result, host) {\n  var message = !!result && !!result.error && !!result.error.message ? '[ethjs-provider-http] ' + result.error.message : '[ethjs-provider-http] Invalid JSON RPC response from host provider ' + host + ': ' + JSON.stringify(result, null, 2);\n  return new Error(message);\n}\n\n/**\n * HttpProvider should be used to send rpc calls over http\n */\nfunction HttpProvider(host, timeout) {\n  if (!(this instanceof HttpProvider)) {\n    throw new Error('[ethjs-provider-http] the HttpProvider instance requires the \"new\" flag in order to function normally (e.g. `const eth = new Eth(new HttpProvider());`).');\n  }\n  if (typeof host !== 'string') {\n    throw new Error('[ethjs-provider-http] the HttpProvider instance requires that the host be specified (e.g. `new HttpProvider(\"http://localhost:8545\")` or via service like infura `new HttpProvider(\"http://ropsten.infura.io\")`)');\n  }\n\n  var self = this;\n  self.host = host;\n  self.timeout = timeout || 0;\n}\n\n/**\n * Should be used to make async request\n *\n * @method sendAsync\n * @param {Object} payload\n * @param {Function} callback triggered on end with (err, result)\n */\nHttpProvider.prototype.sendAsync = function (payload, callback) {\n  // eslint-disable-line\n  var self = this;\n  var request = new XHR2(); // eslint-disable-line\n\n  request.timeout = self.timeout;\n  request.open('POST', self.host, true);\n  request.setRequestHeader('Content-Type', 'application/json');\n\n  request.onreadystatechange = function () {\n    if (request.readyState === 4 && request.timeout !== 1) {\n      var result = request.responseText; // eslint-disable-line\n      var error = null; // eslint-disable-line\n\n      try {\n        result = JSON.parse(result);\n      } catch (jsonError) {\n        error = invalidResponseError(request.responseText, self.host);\n      }\n\n      callback(error, result);\n    }\n  };\n\n  request.ontimeout = function () {\n    callback('[ethjs-provider-http] CONNECTION TIMEOUT: http request timeout after ' + self.timeout + ' ms. (i.e. your connect has timed out for whatever reason, check your provider).', null);\n  };\n\n  try {\n    request.send(JSON.stringify(payload));\n  } catch (error) {\n    callback('[ethjs-provider-http] CONNECTION ERROR: Couldn\\'t connect to node \\'' + self.host + '\\': ' + JSON.stringify(error, null, 2), null);\n  }\n};\n\nmodule.exports = HttpProvider;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ethjs-provider-http/lib/index.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nmodule.exports = EthRPC;\n\n/**\n * Constructs the EthRPC instance\n *\n * @method EthRPC\n * @param {Object} cprovider the eth rpc provider web3 standard..\n * @param {Object} options the options, if any\n * @returns {Object} ethrpc instance\n */\nfunction EthRPC(cprovider, options) {\n  var self = this;\n  var optionsObject = options || {};\n\n  if (!(this instanceof EthRPC)) {\n    throw new Error('[ethjs-rpc] the EthRPC object requires the \"new\" flag in order to function normally (i.e. `const eth = new EthRPC(provider);`).');\n  }\n\n  self.options = Object.assign({\n    jsonSpace: optionsObject.jsonSpace || 0,\n    max: optionsObject.max || 9999999999999\n  });\n  self.idCounter = Math.floor(Math.random() * self.options.max);\n  self.setProvider = function (provider) {\n    if (typeof provider !== 'object') {\n      throw new Error('[ethjs-rpc] the EthRPC object requires that the first input \\'provider\\' must be an object, got \\'' + typeof provider + '\\' (i.e. \\'const eth = new EthRPC(provider);\\')');\n    }\n\n    self.currentProvider = provider;\n  };\n  self.setProvider(cprovider);\n}\n\n/**\n * The main send async method\n *\n * @method sendAsync\n * @param {Object} payload the rpc payload object\n * @param {Function} cb the async standard callback\n * @callback {Object|Array|Boolean|String} vary result instance output\n */\nEthRPC.prototype.sendAsync = function sendAsync(payload, cb) {\n  var self = this;\n  self.idCounter = self.idCounter % self.options.max;\n  self.currentProvider.sendAsync(createPayload(payload, self.idCounter++), function (err, response) {\n    var responseObject = response || {};\n\n    if (err || responseObject.error) {\n      var payloadErrorMessage = '[ethjs-rpc] ' + (responseObject.error && 'rpc' || '') + ' error with payload ' + JSON.stringify(payload, null, self.options.jsonSpace) + ' ' + (err || JSON.stringify(responseObject.error, null, self.options.jsonSpace));\n      return cb(new Error(payloadErrorMessage), null);\n    }\n\n    return cb(null, responseObject.result);\n  });\n};\n\n/**\n * A simple create payload method\n *\n * @method createPayload\n * @param {Object} data the rpc payload data\n * @param {String} id the rpc data payload ID\n * @returns {Object} payload the completed payload object\n */\nfunction createPayload(data, id) {\n  return Object.assign({\n    id: id,\n    jsonrpc: '2.0',\n    params: []\n  }, data);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ethjs-rpc/lib/index.js\n// module id = 2\n// module chunks = 0","module.exports = XMLHttpRequest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xhr2/lib/browser.js\n// module id = 3\n// module chunks = 0"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACxEA;;;;;;;;;;;;;","sourceRoot":""}